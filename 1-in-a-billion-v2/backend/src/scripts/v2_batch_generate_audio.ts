/**
 * BATCH AUDIO GENERATION
 *
 * Reads all .reading.txt files from the media folder and generates
 * audio for each via the local TTS endpoint (Replicate Chatterbox).
 *
 * Prerequisites:
 *   1. Backend running: npm run dev
 *   2. .reading.txt files in the output directory (generated by v2_generate_triplet_pdfs.ts)
 *   3. Replicate API token configured (Supabase api_keys or REPLICATE_API_TOKEN env)
 *
 * Usage:
 *   npx tsx src/scripts/v2_batch_generate_audio.ts
 */

import { config } from 'dotenv';
import { join } from 'path';
import fs from 'fs';
import path from 'path';
import axios from 'axios';

config({ path: join(process.cwd(), '.env') });

const PORT = process.env.PORT || '8787';
const TTS_URL = `http://localhost:${PORT}/api/audio/generate-tts`;
const MEDIA_DIR = process.env.MEDIA_DIR || '/Users/michaelperinwogenburg/Desktop/1-in-a-billion-media';
const VOICE_URL = 'https://qdfikbgwuauertfmkmzk.supabase.co/storage/v1/object/public/voices/david.wav';

async function main() {
  console.log('üîä BATCH AUDIO GENERATION');
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

  // 1. Find all .reading.txt files
  const allFiles = fs.readdirSync(MEDIA_DIR);
  const textFiles = allFiles
    .filter((f) => f.endsWith('.reading.txt'))
    .sort();

  if (textFiles.length === 0) {
    console.error('‚ùå No .reading.txt files found in', MEDIA_DIR);
    console.error('   Run v2_generate_triplet_pdfs.ts first to generate reading texts.');
    process.exit(1);
  }

  console.log(`üìÑ Found ${textFiles.length} reading text files:`);
  textFiles.forEach((f) => console.log(`   - ${f}`));
  console.log();

  // 2. Check backend is running
  try {
    await axios.get(`http://localhost:${PORT}/health`, { timeout: 5000 });
    console.log('‚úÖ Backend reachable\n');
  } catch (e: any) {
    console.error('‚ùå Backend not reachable. Start it first: npm run dev');
    process.exit(1);
  }

  // 3. Process each file
  const results: Array<{ file: string; success: boolean; audioPath?: string; error?: string }> = [];

  for (let i = 0; i < textFiles.length; i++) {
    const textFile = textFiles[i];
    const textPath = path.join(MEDIA_DIR, textFile);
    const text = fs.readFileSync(textPath, 'utf8');
    const baseName = textFile.replace('.reading.txt', '');
    const audioOutPath = path.join(MEDIA_DIR, `${baseName}.mp3`);

    // Skip if audio already exists
    if (fs.existsSync(audioOutPath)) {
      console.log(`‚è≠Ô∏è  [${i + 1}/${textFiles.length}] Skipping ${baseName} (audio already exists)`);
      results.push({ file: textFile, success: true, audioPath: audioOutPath });
      continue;
    }

    console.log(`üéôÔ∏è  [${i + 1}/${textFiles.length}] Generating audio for: ${baseName}`);
    console.log(`   Text length: ${text.length} chars`);

    try {
      const res = await axios.post(
        TTS_URL,
        {
          text,
          provider: 'chatterbox',
          exaggeration: 0.3,
          audioUrl: VOICE_URL,
          title: baseName.replace(/_/g, ' '),
        },
        {
          headers: { 'Content-Type': 'application/json' },
          timeout: 30 * 60 * 1000, // 30 min timeout per reading
        }
      );

      if (!res.data?.success || !res.data?.audioBase64) {
        console.error(`   ‚ùå TTS returned no audio: ${res.data?.message || 'unknown'}`);
        results.push({ file: textFile, success: false, error: res.data?.message || 'no audio' });
        continue;
      }

      const buf = Buffer.from(res.data.audioBase64, 'base64');
      fs.writeFileSync(audioOutPath, buf);
      const sizeKb = buf.length / 1024;
      console.log(`   ‚úÖ Saved: ${audioOutPath} (${sizeKb.toFixed(1)} KB)`);
      results.push({ file: textFile, success: true, audioPath: audioOutPath });
    } catch (e: any) {
      const errMsg = e.response?.data?.message || e.message || 'unknown';
      console.error(`   ‚ùå TTS failed: ${errMsg}`);
      results.push({ file: textFile, success: false, error: errMsg });
    }

    // Small delay between readings
    if (i < textFiles.length - 1) {
      console.log('   ‚è≥ Waiting 3s before next...\n');
      await new Promise((r) => setTimeout(r, 3000));
    }
  }

  // 4. Summary
  console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  console.log('BATCH AUDIO GENERATION COMPLETE');
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  const successes = results.filter((r) => r.success);
  const failures = results.filter((r) => !r.success);
  console.log(`‚úÖ Success: ${successes.length}/${results.length}`);
  if (failures.length > 0) {
    console.log(`‚ùå Failed: ${failures.length}`);
    failures.forEach((f) => console.log(`   - ${f.file}: ${f.error}`));
  }
  successes.forEach((s) => console.log(`   üìÅ ${s.audioPath}`));
}

main().catch((err) => {
  console.error('‚ùå Batch audio generation failed:', err?.message || String(err));
  process.exitCode = 1;
});
