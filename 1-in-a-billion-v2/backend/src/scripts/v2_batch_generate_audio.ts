/**
 * BATCH AUDIO GENERATION
 *
 * Reads all .reading.txt files from the media folder and generates
 * audio for each via the local TTS endpoint (Replicate Chatterbox).
 *
 * Prerequisites:
 *   1. Backend running: npm run dev
 *   2. .reading.txt files in the output directory (generated by v2_generate_triplet_pdfs.ts)
 *   3. Replicate API token configured (Supabase api_keys or REPLICATE_API_TOKEN env)
 *
 * Usage:
 *   npx tsx src/scripts/v2_batch_generate_audio.ts
 */

import { config } from 'dotenv';
import { join } from 'path';
import fs from 'fs';
import path from 'path';
import axios from 'axios';

config({ path: join(process.cwd(), '.env') });

const PORT = process.env.PORT || '8787';
const TTS_URL = `http://localhost:${PORT}/api/audio/generate-tts`;
const MEDIA_DIR = process.env.MEDIA_DIR || '/Users/michaelperinwogenburg/Desktop/1-in-a-billion-media';
const VOICE_URL = 'https://qdfikbgwuauertfmkmzk.supabase.co/storage/v1/object/public/voices/david.wav';
const FILE_DELAY_MS = parseInt(process.env.BATCH_AUDIO_FILE_DELAY_MS || '0', 10);

function prettyName(token: string): string {
  return String(token || '')
    .replace(/-/g, ' ')
    .replace(/\b\w/g, (c) => c.toUpperCase())
    .trim();
}

function detectSystemLabel(baseName: string): string {
  const value = baseName.toLowerCase();
  if (value.includes('western-astrology')) return 'Western Astrology';
  if (value.includes('vedic-astrology-jyotish') || value.includes('vedic-astrology')) return 'Vedic Astrology';
  if (value.includes('human-design')) return 'Human Design';
  if (value.includes('gene-keys')) return 'Gene Keys';
  if (value.includes('kabbalah')) return 'Kabbalah';
  if (value.includes('verdict')) return 'Final Verdict';
  return 'Compatibility';
}

function buildSpokenIntroFromFile(baseName: string): string {
  const generatedOn = new Date().toLocaleDateString('en-GB', {
    day: '2-digit',
    month: 'long',
    year: 'numeric',
  });
  const system = detectSystemLabel(baseName);

  if (baseName.startsWith('verdict_')) {
    const parts = baseName.split('_');
    const p1 = prettyName(parts[1] || 'Person 1');
    const p2 = prettyName(parts[2] || 'Person 2');
    return `This is the final verdict reading for ${p1} and ${p2}. Generated on ${generatedOn} by 1 in a billion app, powered by forbidden-yoga dot com.`;
  }

  if (baseName.startsWith('overlay_')) {
    const parts = baseName.split('_');
    const p1 = prettyName(parts[1] || 'Person 1');
    const p2 = prettyName(parts[2] || 'Person 2');
    return `This is a ${system} compatibility reading for ${p1} and ${p2}. Generated on ${generatedOn} by 1 in a billion app, powered by forbidden-yoga dot com.`;
  }

  if (baseName.startsWith('individual_')) {
    const parts = baseName.split('_');
    const person = prettyName(parts[1] || 'Person 1');
    return `This is a ${system} reading for ${person}. Generated on ${generatedOn} by 1 in a billion app, powered by forbidden-yoga dot com.`;
  }

  return `This is an audio reading. Generated on ${generatedOn} by 1 in a billion app, powered by forbidden-yoga dot com.`;
}

type TimingRow = {
  file: string;
  baseName: string;
  success: boolean;
  durationSec: number;
  textChars: number;
  audioPath?: string;
  error?: string;
};

async function main() {
  console.log('üîä BATCH AUDIO GENERATION');
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n');

  // 1. Find all .reading.txt files
  const allFiles = fs.readdirSync(MEDIA_DIR);
  const textFiles = allFiles
    .filter((f) => f.endsWith('.reading.txt'))
    .sort();

  if (textFiles.length === 0) {
    console.error('‚ùå No .reading.txt files found in', MEDIA_DIR);
    console.error('   Run v2_generate_triplet_pdfs.ts first to generate reading texts.');
    process.exit(1);
  }

  console.log(`üìÑ Found ${textFiles.length} reading text files:`);
  textFiles.forEach((f) => console.log(`   - ${f}`));
  console.log();

  // 2. Check backend is running
  try {
    await axios.get(`http://localhost:${PORT}/health`, { timeout: 5000 });
    console.log('‚úÖ Backend reachable\n');
  } catch (e: any) {
    console.error('‚ùå Backend not reachable. Start it first: npm run dev');
    process.exit(1);
  }

  // 3. Process each file
  const results: TimingRow[] = [];
  const batchStartedAt = Date.now();

  for (let i = 0; i < textFiles.length; i++) {
    const textFile = textFiles[i];
    const textPath = path.join(MEDIA_DIR, textFile);
    const text = fs.readFileSync(textPath, 'utf8');
    const baseName = textFile.replace('.reading.txt', '');
    const audioOutPath = path.join(MEDIA_DIR, `${baseName}.mp3`);

    // Skip if audio already exists
    if (fs.existsSync(audioOutPath)) {
      console.log(`‚è≠Ô∏è  [${i + 1}/${textFiles.length}] Skipping ${baseName} (audio already exists)`);
      results.push({
        file: textFile,
        baseName,
        success: true,
        durationSec: 0,
        textChars: text.length,
        audioPath: audioOutPath,
      });
      continue;
    }

    console.log(`üéôÔ∏è  [${i + 1}/${textFiles.length}] Generating audio for: ${baseName}`);
    console.log(`   Text length: ${text.length} chars`);

    const startedAt = Date.now();
    const spokenIntro = buildSpokenIntroFromFile(baseName);

    try {
      const res = await axios.post(
        TTS_URL,
        {
          text,
          provider: 'chatterbox',
          exaggeration: 0.3,
          audioUrl: VOICE_URL,
          title: baseName.replace(/_/g, ' '),
          spokenIntro,
          includeIntro: true,
        },
        {
          headers: { 'Content-Type': 'application/json' },
          timeout: 120 * 60 * 1000, // 120 min timeout per reading (long chunked TTS jobs)
        }
      );

      if (!res.data?.success || !res.data?.audioBase64) {
        const durationSec = Number(((Date.now() - startedAt) / 1000).toFixed(1));
        console.error(`   ‚ùå TTS returned no audio: ${res.data?.message || 'unknown'}`);
        results.push({
          file: textFile,
          baseName,
          success: false,
          durationSec,
          textChars: text.length,
          error: res.data?.message || 'no audio',
        });
        continue;
      }

      const buf = Buffer.from(res.data.audioBase64, 'base64');
      fs.writeFileSync(audioOutPath, buf);
      const sizeKb = buf.length / 1024;
      const durationSec = Number(((Date.now() - startedAt) / 1000).toFixed(1));
      console.log(`   ‚úÖ Saved: ${audioOutPath} (${sizeKb.toFixed(1)} KB) in ${durationSec}s`);
      results.push({
        file: textFile,
        baseName,
        success: true,
        durationSec,
        textChars: text.length,
        audioPath: audioOutPath,
      });
    } catch (e: any) {
      const errMsg = e.response?.data?.message || e.message || 'unknown';
      const durationSec = Number(((Date.now() - startedAt) / 1000).toFixed(1));
      console.error(`   ‚ùå TTS failed: ${errMsg}`);
      results.push({
        file: textFile,
        baseName,
        success: false,
        durationSec,
        textChars: text.length,
        error: errMsg,
      });
    }

    // Optional delay between readings
    if (i < textFiles.length - 1 && FILE_DELAY_MS > 0) {
      console.log(`   ‚è≥ Waiting ${FILE_DELAY_MS}ms before next...\n`);
      await new Promise((r) => setTimeout(r, FILE_DELAY_MS));
    }
  }

  // 4. Summary
  console.log('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  console.log('BATCH AUDIO GENERATION COMPLETE');
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  const successes = results.filter((r) => r.success);
  const failures = results.filter((r) => !r.success);
  console.log(`‚úÖ Success: ${successes.length}/${results.length}`);
  if (failures.length > 0) {
    console.log(`‚ùå Failed: ${failures.length}`);
    failures.forEach((f) => console.log(`   - ${f.file}: ${f.error}`));
  }
  successes.forEach((s) => console.log(`   üìÅ ${s.audioPath}`));

  const totalDurationSec = Number(((Date.now() - batchStartedAt) / 1000).toFixed(1));
  const report = {
    generatedAt: new Date().toISOString(),
    mediaDir: MEDIA_DIR,
    totalFiles: results.length,
    successCount: successes.length,
    failureCount: failures.length,
    totalDurationSec,
    averageSuccessDurationSec: successes.length > 0
      ? Number((successes.reduce((acc, row) => acc + row.durationSec, 0) / successes.length).toFixed(1))
      : 0,
    results,
  };
  const stamp = new Date().toISOString().replace(/[:.]/g, '').replace('T', '_').slice(0, 15);
  const reportPath = path.join(MEDIA_DIR, `audio_generation_timing_${stamp}.json`);
  fs.writeFileSync(reportPath, JSON.stringify(report, null, 2), 'utf8');
  console.log(`üßæ Timing report: ${reportPath}`);
}

main().catch((err) => {
  console.error('‚ùå Batch audio generation failed:', err?.message || String(err));
  process.exitCode = 1;
});
