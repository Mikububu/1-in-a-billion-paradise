# Codex Audit Brief ‚Äî Two-Call Wound Engine
## 1-in-a-billion-v2 / backend

---

## What We Did and Why

### The Problem (Pre-Rebuild)

Individual readings (western, vedic, human_design, gene_keys, kabbalah) were generated by a
legacy pipeline with these components:

1. **Digest call** ‚Äî a preliminary LLM call that produced structured NARRATIVE_ARC / BIG3_SIGNATURE /
   WEATHER_NOTES / THE_WOUND fields from raw chart data
2. **Composition engine** ‚Äî assembled 25,000-character prompts from MD layer files
   (src/prompts/systems/*.ts, src/prompts/core/*.ts, src/prompts/styles/*.ts)
3. **Main writing call** ‚Äî model tried to write inside 25k chars of compliance instructions
4. **Expansion passes** ‚Äî if output < WORD_COUNT_LIMITS.min, the worker auto-continued 1-3 times

The result: readings that padded already-complete material. The model would write a clean, complete
~3,500-word reading in its first pass, then expansion passes fired and added 2,500 words of the same
insight restated with fresh metaphors but no new consequence. Quality collapsed in the second half.

Root cause: the pipeline legislated quality instead of creating conditions for it.

### The Solution (New Architecture)

Every individual system now runs exactly three steps ‚Äî pure code, then two LLM calls:

```
Raw chart data (800+ lines)
       ‚Üì
   stripXChartData()           ‚Üê pure TypeScript, no LLM, ~35-40 lines out
       ‚Üì
   buildXWoundPrompt()         ‚Üê Call 1: ~20 lines in, 80-120 word wound paragraph out
       ‚Üì
   buildXWritingPrompt()       ‚Üê Call 2: wound paragraph + stripped data ‚Üí 3,500-word reading
```

No digest. No expansion passes. No compliance rewrites. Model stops when done.

---

## Files Written / Modified

### NEW ‚Äî Wound Engine (all five systems)

```
src/promptEngine/woundEngine/westernWound.ts
src/promptEngine/woundEngine/vedicWound.ts
src/promptEngine/woundEngine/humanDesignWound.ts
src/promptEngine/woundEngine/geneKeysWound.ts
src/promptEngine/woundEngine/kabbalahWound.ts
```

Each file exports three functions with identical signatures:

```typescript
stripXChartData(raw: string): string
buildXWoundPrompt(params: { personName: string; strippedChartData: string }): string
buildXWritingPrompt(params: { personName: string; wound: string; strippedChartData: string }): string
```

### MODIFIED ‚Äî textWorker.ts

`src/workers/textWorker.ts`

All five wound engines are imported at the top (lines 20-46). In the task execution block, before
the legacy prompt engine runs, there are five sequential if-blocks, one per system:

```typescript
// Lines ~607-657 (western)
if (system === 'western' && docType !== 'overlay') { ... generationComplete = true; }

// Lines ~659-693 (vedic)
if (system === 'vedic' && docType !== 'overlay') { ... generationComplete = true; }

// Lines ~695-730 (human_design)
if (!generationComplete && system === 'human_design' && docType !== 'overlay') { ... generationComplete = true; }

// Lines ~732-767 (gene_keys)
if (!generationComplete && system === 'gene_keys' && docType !== 'overlay') { ... generationComplete = true; }

// Lines ~769-804 (kabbalah)
if (!generationComplete && system === 'kabbalah' && docType !== 'overlay') { ... generationComplete = true; }
```

When `generationComplete = true`, the worker skips the legacy pipeline and skips expansion passes.

The `generationComplete` flag also controls `preserveSurrealHeadlines`:

```typescript
let preserveSurrealHeadlines = generationComplete
  ? true   // wound engine always uses surreal headlines
  : String(composedV2?.diagnostics?.styleLayerId || '').includes('incarnation');
```

Expansion passes still fire for non-wound-engine paths (verdict, overlay) but are bypassed for all
five individual systems once wound engine sets generationComplete.

---

## What Codex Needs to Audit and Fix

### BUG 1 ‚Äî Western cost logging fires twice (critical)

In the western block, `writingUsage2` is logged BEFORE the writing call actually runs:

```typescript
const writingPrompt = buildWesternWritingPrompt({ personName: subject.name, wound, strippedChartData: stripped });
const writingUsage2 = llmPaid.getLastUsage();   // ‚Üê THIS IS STILL THE WOUND CALL'S USAGE
if (writingUsage2) {
  await logLLMCost(..., `text_western_writing_${docType}`);  // ‚Üê Logs wound cost as writing cost
}
// ...then the actual writing call runs...
text = await llmPaid.generateStreaming(writingPrompt, ...);
const writingUsage = llmPaid.getLastUsage();    // ‚Üê This IS the writing usage
if (writingUsage) {
  await logLLMCost(..., `text_western_writing_${docType}`);  // ‚Üê Logs again correctly
}
```

Fix: delete the premature `writingUsage2` block entirely. Only log after the writing call completes.

### BUG 2 ‚Äî Vedic wound block missing `!generationComplete` guard (critical)

The western block correctly sets `generationComplete = true`. The vedic block immediately follows
but does NOT check `!generationComplete` before entering:

```typescript
// After western block:
if (!generationComplete) {  // ‚Üê This outer guard wraps the legacy engine
  if (system === 'vedic' && docType !== 'overlay') {  // ‚Üê But vedic also inside this block?
```

Need to verify exact nesting. If vedic, HD, gene_keys, kabbalah blocks are inside
`if (!generationComplete)` correctly, this may be fine. But if the outer block closes before vedic
and vedic has no guard, a western reading could also trigger vedic. Audit the brace structure around
lines 659-804 and confirm each system block has the `!generationComplete` guard. Add it if missing.

### BUG 3 ‚Äî stripVedicChartData has broken graha matching (verified)

In `vedicWound.ts`, the graha filter:

```typescript
const KEEP_GRAHAS = new Set([
  'surya (sun)', 'chandra (moon)', 'mangal (mars)',
  'shani (saturn)', 'rahu', 'ketu',
]);

if (KEEP_GRAHAS.has([...KEEP_GRAHAS].find(g => lc.includes(g)) || '')) {
  out.push(line);
}
```

This logic is broken. It spreads KEEP_GRAHAS into an array, finds an element that the line includes,
then checks if KEEP_GRAHAS has that element ‚Äî which it always will if find() returns anything. But
if find() returns undefined, the fallback `|| ''` means it checks `KEEP_GRAHAS.has('')` which is
false. So it technically works but the logic is backwards and confusing. Worse: if the raw chart
data uses different casing or formatting (e.g. "Surya (Sun)" vs "surya (sun)"), the lowercase
comparison `lc.includes(g)` may fail silently and strip out all grahas.

Fix: simplify to a direct string check:

```typescript
const GRAHA_KEYWORDS = ['surya', 'chandra', 'mangal', 'shani', 'rahu', 'ketu'];
if (inGrahas && /^- /.test(t)) {
  const lc = t.toLowerCase();
  if (GRAHA_KEYWORDS.some(g => lc.includes(g))) {
    out.push(line);
  }
  continue;
}
```

### BUG 4 ‚Äî stripHDChartData exits section tracking on empty line incorrectly

In `humanDesignWound.ts`:

```typescript
} else if (t === '') {
  inPersonality = false;
  inDesign = false;
  out.push(line);
}
```

Any blank line inside personality/design activations resets both section flags. If the raw HD chart
has blank lines between activation entries (which is likely), all activations after the first blank
line get passed through unfiltered to `out.push(line)` via the fallback. Check the actual HD chart
data format. If blank lines appear within sections, the exit condition should be a new section header,
not an empty line.

### BUG 5 ‚Äî stripGeneKeysChartData drops Activation Sequence header section routing

In `geneKeysWound.ts`:

```typescript
if (/^ACTIVATION SEQUENCE/.test(t)) { inVenus = false; out.push(line); continue; }
```

When ACTIVATION SEQUENCE header appears, `inVenus` and `inPearl` are cleared. But there is no
`inActivation = true` flag set. All activation sequence lines then fall through to the final
`out.push(line)`. This means activation sequence content IS included, but only incidentally via
fallthrough ‚Äî not explicitly. This will break if any other section appears between ACTIVATION
SEQUENCE and VENUS SEQUENCE. Add an explicit `inActivation` flag and handle it intentionally.

### BUG 6 ‚Äî wordCounts.ts min/target/max changed globally but only tested on western

`src/prompts/config/wordCounts.ts` was changed from:
- min: 6500, target: 8500, max: 10000

To:
- min: 3000, target: 3500, max: 4000

The HARD_FLOOR_WORDS in textWorker uses `WORD_COUNT_LIMITS.min`. For wound engine systems,
expansion passes are skipped via `generationComplete`. But for overlay and verdict docs, expansion
passes still fire using this 3,000-word floor ‚Äî which may be too low for those multi-person docs.

Verdict and overlay probably need their own floor, not the individual reading floor.

Fix options:
- Add separate WORD_COUNT_LIMITS_OVERLAY and WORD_COUNT_LIMITS_VERDICT constants
- Or set HARD_FLOOR_WORDS conditionally based on docType before the expansion block

### BUG 7 ‚Äî overlay docType falls through to legacy prompt engine without explicit guard

When docType === 'overlay', none of the five wound-engine blocks fire (they all check
`docType !== 'overlay'`). The code falls through to the legacy `composePromptFromJobStartPayload`
path. This is intentional ‚Äî overlays need both people's data and use the old synastry prompts.

But confirm that `chartDataForPrompt` (the variable passed to the legacy engine) is being set
correctly for overlay. There is a variable `chartDataForPrompt` used in the old prompt path and
`chartData` used in the wound engine path ‚Äî verify these are the same variable or properly aliased.
If wound engine blocks use `chartData` and the legacy engine uses `chartDataForPrompt`, confirm
they point to the same data or that `chartDataForPrompt` is explicitly assigned from `chartData`.

### BUG 8 ‚Äî `preserveSurrealHeadlines` set before generationComplete is known

```typescript
let preserveSurrealHeadlines = generationComplete
  ? true
  : String(composedV2?.diagnostics?.styleLayerId || '').includes('incarnation');
```

This line appears BEFORE the five wound-engine if-blocks run. At this point `generationComplete`
is always `false`. So `preserveSurrealHeadlines` is always set by the else branch (checking
styleLayerId). Then after generationComplete is set to true, `preserveSurrealHeadlines` is never
updated.

The expansion pass uses `preserveSurrealHeadlines` in its prompt. For wound engine systems,
expansion passes don't fire, so this bug is currently harmless. But the variable is also used in
`tightenParagraphs` and `cleanReadingText` calls inside the wound engine blocks themselves ‚Äî and
those calls happen inside the blocks where generationComplete has just been set. So those calls
use the stale value.

Fix: either move `preserveSurrealHeadlines` assignment to after the wound engine blocks, or set it
explicitly inside each wound engine block:

```typescript
// Inside each wound engine block, just before tightenParagraphs:
preserveSurrealHeadlines = true;
```

---

## Files Codex Should NOT Touch

These are dead code paths that still compile but are bypassed for all five individual systems.
Do not refactor or delete them yet ‚Äî they are still used for overlay and verdict docs:

- `src/promptEngine/digests/westernDigest.ts` (digest call bypassed for wound engine)
- `src/promptEngine/digests/vedicDigest.ts`
- `src/prompts/systems/western.ts` (MD layer system, bypassed for wound engine)
- `src/prompts/systems/vedic.ts`
- `src/prompts/systems/human-design.ts`
- `src/prompts/systems/gene-keys.ts`
- `src/prompts/systems/kabbalah.ts`
- `src/promptEngine/composePrompt.ts`
- `src/promptEngine/layerRegistry.ts`

---

## What Good Looks Like When Bugs Are Fixed

1. Western reading: no duplicate cost log entries in the DB for wound call
2. Vedic stripped chart: all six grahas (Surya/Chandra/Mangal/Shani/Rahu/Ketu) visible in output
3. HD stripped chart: activation section keeps Sun/Earth/Moon for both Personality and Design
   even when blank lines appear between planet entries
4. Gene Keys stripped chart: Activation Sequence content preserved intentionally, not by fallthrough
5. Overlay docs: expansion pass fires with a higher word floor than individual docs
6. All five individual systems: `preserveSurrealHeadlines = true` applied before `tightenParagraphs`

---

## Test Command

To trigger a test reading and verify wound engine is firing (not legacy pipeline):

Look for these console log lines in the worker output:
```
ü©∏ [TextWorker] Western wound call for [name]...
‚úÖ [TextWorker] Western wound: [first 80 chars of wound]...
‚úçÔ∏è [TextWorker] Western writing call for [name]...
‚úÖ [TextWorker] Western reading complete: [N] words
```

If you see `üß© [PromptEngine] style=...` before the reading text, the legacy engine ran instead of
the wound engine.
